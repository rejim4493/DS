#include <iostream>
using namespace std;

#define MAX_STACK_SIZE 100
#define MAZE_ROWS 6
#define MAZE_COLS 6

// æ–¹å‘åç§»çµæ§‹
struct offsets {
    int vert;
    int horiz;
};

// å †ç–Šå…ƒç´ çµæ§‹
struct element {
    int row;
    int col;
    int dir;
};

// å…«å€‹æ–¹å‘ï¼šä¸Šã€å³ä¸Šã€å³ã€å³ä¸‹ã€ä¸‹ã€å·¦ä¸‹ã€å·¦ã€å·¦ä¸Š
offsets moves[8] = {
    {-1, 0},  // ä¸Š
    {-1, 1},  // å³ä¸Š
    {0, 1},   // å³
    {1, 1},   // å³ä¸‹
    {1, 0},   // ä¸‹
    {1, -1},  // å·¦ä¸‹
    {0, -1},  // å·¦
    {-1, -1}  // å·¦ä¸Š
};

// è¿·å®®åœ°åœ–ï¼ˆåŠ ä¸Šé‚Šç•Œï¼‰
int maze[MAZE_ROWS + 2][MAZE_COLS + 2] = {
    {1,1,1,1,1,1,1,1},
    {1,0,0,1,0,0,0,1},
    {1,0,1,0,1,1,0,1},
    {1,0,1,0,0,0,0,1},
    {1,0,1,1,1,1,0,1},
    {1,0,0,0,0,0,0,1},
    {1,1,1,1,1,1,1,1},
};

// æ¨™è¨˜å·²èµ°éŽçš„ä½ç½®
int mark[MAZE_ROWS + 2][MAZE_COLS + 2] = {0};

// å †ç–Š
element stack[MAX_STACK_SIZE];
int top = -1;

// push å‡½å¼
void push(element item) {
    if (top >= MAX_STACK_SIZE - 1) {
        cout << "Stack overflow\n";
        return;
    }
    stack[++top] = item;
}

// pop å‡½å¼
element pop() {
    if (top == -1) {
        cout << "Stack underflow\n";
        return {-1, -1, -1};
    }
    return stack[top--];
}

// DFS è§£è¿·å®®ä¸»é‚è¼¯
void solveMaze() {
    int row = 1, col = 1;
    mark[row][col] = 1;

    element temp = {row, col, 0};
    push(temp);

    while (top != -1) {
        temp = pop();
        row = temp.row;
        col = temp.col;
        int dir = temp.dir;

        while (dir < 8) {
            int next_row = row + moves[dir].vert;
            int next_col = col + moves[dir].horiz;

            if (next_row == MAZE_ROWS && next_col == MAZE_COLS) {
                // æ‰¾åˆ°å‡ºå£
                cout << "Path found:\n";
                for (int i = 0; i <= top; i++)
                    cout << "(" << stack[i].row << "," << stack[i].col << ") â†’ ";
                cout << "(" << row << "," << col << ") â†’ ";
                cout << "(" << MAZE_ROWS << "," << MAZE_COLS << ")\n";
                return;
            }

            if (maze[next_row][next_col] == 0 && mark[next_row][next_col] == 0) {
                mark[next_row][next_col] = 1;

                // å›žå­˜ç›®å‰ä½ç½®èˆ‡ä¸‹ä¸€å€‹æ–¹å‘
                temp.row = row;
                temp.col = col;
                temp.dir = dir + 1;
                push(temp);

                // ç§»å‹•åˆ°ä¸‹ä¸€æ ¼
                row = next_row;
                col = next_col;
                dir = 0;
            } else {
                dir++;
            }
        }
    }

    cout << "No path found\n";
}

int main() {
    solveMaze();
    return 0;
}

/*output
[?2004l
Path found:
(1,1) â†’ (1,2) â†’ (2,3) â†’ (1,4) â†’ (1,5) â†’ (1,6) â†’ (2,6) â†’ (3,6) â†’ (4,6) â†’ (5,6) â†’ (6,6)
[?2004h
*/
